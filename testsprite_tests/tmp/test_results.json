[
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "6f9b4395-eb57-421a-b450-8c426b4a8d89",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC001-Admin login with valid credentials",
    "description": "Verify that the admin can log in successfully with valid username and password.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Admin Paneli' to go to the admin login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter valid username and password, then click login button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the admin is redirected to the admin panel with access granted.\n        frame = context.pages[-1]\n        await page.wait_for_timeout(3000)\n        # Check the page title\n        assert await frame.title() == 'MODERN QUIZ - Admin Paneli'\n        # Check for presence of key elements in the admin panel to confirm successful login\n        header_menu = await frame.locator('xpath=//div[contains(@class, \"header\")]//div[contains(text(), \"Ana Menü\")]').count()\n        assert header_menu > 0\n        server_status_text = await frame.locator('xpath=//div[contains(text(), \"Soru yönetimi ve sistem kontrolü\")]').count()\n        assert server_status_text > 0\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112335518262//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.751Z",
    "modified": "2025-10-10T16:05:35.697Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "0baf7b68-5fad-4d6a-81c5-bf789caa480d",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC002-Admin login with invalid credentials",
    "description": "Verify that admin login fails when using invalid username or password and proper error message is shown.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Admin Paneli' to go to admin login page.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Enter invalid username and password, then click login button.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidUser')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidPass')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        error_message_locator = frame.locator('xpath=html/body/div/div/div/div[4]/div')\n        await page.wait_for_timeout(3000)\n        assert await error_message_locator.is_visible(), 'Error message is not visible after invalid login attempt'\n        error_text = await error_message_locator.text_content()\n        assert 'invalid' in error_text.lower() or 'hata' in error_text.lower() or 'geçersiz' in error_text.lower(), f'Unexpected error message text: {error_text}'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112326083124//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.759Z",
    "modified": "2025-10-10T16:05:26.225Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "e514df95-6a4f-4156-8d2e-01067e23db9f",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC003-Manual quiz question addition by admin",
    "description": "Ensure the admin can manually add a quiz question with all required fields and it is correctly saved.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-10-10T16:03:06.765Z",
    "modified": "2025-10-10T16:03:06.765Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "e5989fb0-ab88-454b-b8f9-e2afb0d04b80",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC004-Bulk quiz question upload via Excel with valid file",
    "description": "Verify that uploading a well-formed Excel file where questions are correctly formatted results in successful addition of all questions.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-10-10T16:03:06.774Z",
    "modified": "2025-10-10T16:03:06.774Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "110c8a9c-2132-4f34-8dbe-9bb8efb9e694",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC005-Bulk quiz question upload via Excel with invalid file format",
    "description": "Ensure that uploading an invalid or corrupted Excel file results in proper validation errors and no questions are added.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Panel to go to login page\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password and click login button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Upload an invalid or corrupted Excel file to test validation\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to upload an invalid or corrupted Excel file by clicking the file input label (index 7) to open file dialog and then simulate file selection or find alternative method to upload file\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the upload button (index 8) to attempt upload after manual selection of invalid or corrupted Excel file, then verify error message and no questions added\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that an error message is shown after uploading invalid or corrupted Excel file\n        error_message_locator = frame.locator('xpath=//div[contains(@class, \"error\") or contains(text(), \"hata\") or contains(text(), \"geçersiz\")]')\n        await error_message_locator.wait_for(state='visible', timeout=5000)\n        error_message_text = await error_message_locator.inner_text()\n        assert error_message_text.strip() != '', 'Expected an error message to be displayed for invalid Excel upload'\n        # Assert that the number of questions has not increased after the failed upload\n        questions_count_locator = frame.locator('xpath=//div[contains(text(), \"questions\") or contains(text(), \"Soru\") or contains(text(), \"questions\")]')\n        questions_count_text = await questions_count_locator.inner_text()\n        import re\n        match = re.search(r'\\d+', questions_count_text)\n        assert match is not None, 'Could not find questions count on the page'\n        questions_count_after_upload = int(match.group(0))\n        assert questions_count_after_upload == 889, f'Questions count changed after invalid upload: {questions_count_after_upload} != 889'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112468660723//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.781Z",
    "modified": "2025-10-10T16:07:48.947Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "2cefd0f3-f05f-40b9-99e4-7bc72cebfeaa",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC006-Server health check API returns expected response",
    "description": "Verify that the backend server health check RESTful API responds with correct status and information.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Use browser console or other available tools to send GET request to backend health check API and verify response status and content\n        frame = context.pages[-1].frame_locator('html > body > div > form > div > div > div > iframe[title=\"reCAPTCHA\"][role=\"presentation\"][name=\"a-u91l22unrqk1\"][src=\"https://www.google.com/recaptcha/enterprise/anchor?ar=1&k=6LdLLIMbAAAAAIl-KLj9p1ePhM-4LCCDbjtJLqRO&co=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbTo0NDM.&hl=en&v=bGi-DxR800F5_ueMVcTwXc6q&size=normal&s=Lynqr5LtlvRyHrFWDW_IeTprerriEYJTWx9zB4qVjuwS-CsZUNBWQoI82AlFyMv_i7_vM2iojdo7Zv7saVsCWTMkSon-_qG198PdLMcpKM6RrDeZ1faifVZm8vKnz8aFAbnoTPLlr72hxBI8lWVpu6pLtaV_4eQlXgGVjg7E3O9dlsLLDnE1cKYvRRG6R1H-RWjVIANojsFPOpI3iGsj04317NPMP5WllOxIt_3mwKn4x5TNLT-F9UPdwpoLFhTnfXqsbBk2j3dEBz9T16_-Vzi3bbafDBU&anchor-ms=20000&execute-ms=15000&cb=umjgzdxxf4kp\"]')\n        elem = frame.locator('xpath=html/body/div[2]/div[3]/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, \"Test failed: Expected result unknown, forcing failure.\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Automated testing of backend server health check API cannot proceed because Google CAPTCHA challenge blocks access to search results and direct navigation to the API endpoint results in browser errors. Manual intervention or alternative testing tools are required to complete this task.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 429 () (at https://www.google.com/sorry/index?continue=https://www.google.com/search%3Fq%3Dsend%2520GET%2520request%2520to%2520http://localhost:8080/health%2520and%2520verify%2520response%2520status%2520200%2520and%2520content%26udm%3D14%26sei%3Dfi7paKi6JIfn1e8P4uaK6QY&q=EgSfkkLCGP_cpMcGIjDs19c-Y2WrikrFT5DEWmEzB3PMoOGml1I6v_5rEyYhIidCbewlOQTpdGlwLZJxaXMyAVJaAUM:0:0)\n[WARNING] An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can escape its sandboxing. (at https://www.google.com/recaptcha/enterprise/anchor?ar=1&k=6LdLLIMbAAAAAIl-KLj9p1ePhM-4LCCDbjtJLqRO&co=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbTo0NDM.&hl=en&v=bGi-DxR800F5_ueMVcTwXc6q&size=normal&s=Lynqr5LtlvRyHrFWDW_IeTprerriEYJTWx9zB4qVjuwS-CsZUNBWQoI82AlFyMv_i7_vM2iojdo7Zv7saVsCWTMkSon-_qG198PdLMcpKM6RrDeZ1faifVZm8vKnz8aFAbnoTPLlr72hxBI8lWVpu6pLtaV_4eQlXgGVjg7E3O9dlsLLDnE1cKYvRRG6R1H-RWjVIANojsFPOpI3iGsj04317NPMP5WllOxIt_3mwKn4x5TNLT-F9UPdwpoLFhTnfXqsbBk2j3dEBz9T16_-Vzi3bbafDBU&anchor-ms=20000&execute-ms=15000&cb=umjgzdxxf4kp:0:0)\n[WARNING] An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can escape its sandboxing. (at https://www.google.com/recaptcha/enterprise/bframe?hl=en&v=bGi-DxR800F5_ueMVcTwXc6q&k=6LdLLIMbAAAAAIl-KLj9p1ePhM-4LCCDbjtJLqRO&bft=0dAFcWeA6efcXPHml0iIbLV-DcCbvx0Exw9askSNAKm6JTr_jMXqHm-fDZeS-VIpNQfihPzNqWr4dx8zc40XUVk9vojjU7IGXqCA:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112342822198//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.787Z",
    "modified": "2025-10-10T16:05:42.956Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "df969798-bac4-4d3a-981a-203114d66443",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC007-Quiz Host starts a sequential game and question flows correctly",
    "description": "Ensure the Quiz Host can start a sequential quiz game, questions are delivered in order, timer counts down correctly, and progression moves forwards.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Oyun Sunucusu' to go to the game host login or control panel.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' button to select sequential game mode.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' (Start Game) button to start the quiz game.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open a new tab and navigate to the player join link to simulate a player joining the game.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Input player name 'TestPlayer' and click 'Oyuna Katıl' to join the game.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPlayer')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Clear the input field, enter a new unique player name, and click 'Oyuna Katıl' to join the game.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPlayer2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Switch back to the Quiz Host tab to start the quiz game now that at least one player has joined.\n        await page.goto('http://localhost:5173/#host', timeout=10000)\n        \n\n        # Locate the host controls to start the quiz game or navigate back to the game mode lobby to start the quiz.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to navigate back to the game host control panel and try to start the quiz again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to enter the sequential mode lobby and start the quiz again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' button to start the quiz game and verify first question broadcast and timer start.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '➡️ Sonraki Soru' button to advance to the next question and verify the question order and timer functionality.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '➡️ Sonraki Soru' button again to advance to question 3 and verify continued sequential progression and timer behavior.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click the '🏁 Oyunu Bitir' (End Game) button to stop the quiz and verify the game ends properly.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert the quiz title is displayed correctly\n        assert await frame.locator('text=MODERN QUIZ').is_visible()\n        # Assert the host status shows server is connected\n        assert await frame.locator('text=Sunucu Bağlı').is_visible()\n        # Assert the first question number is displayed correctly\n        question_number_text = await frame.locator('xpath=//div[contains(text(),\"4 / 890\")]').text_content()\n        assert question_number_text.strip() == '4 / 890'\n        # Assert the question text is correct\n        question_text = await frame.locator('xpath=//div[contains(text(),\"İstanbul'un nüfusu yaklaşık kaç milyondur?\")]').text_content()\n        assert \"İstanbul'un nüfusu yaklaşık kaç milyondur?\" in question_text\n        # Assert the options for navigation buttons are visible\n        assert await frame.locator('text=➡️ Sonraki Soru').is_visible()\n        assert await frame.locator('text=🏁 Oyunu Bitir').is_visible()\n        # Click '➡️ Sonraki Soru' to advance to next question and verify question number increments\n        await frame.locator('text=➡️ Sonraki Soru').click()\n        await page.wait_for_timeout(3000)\n        next_question_number_text = await frame.locator('xpath=//div[contains(text(),\"5 / 890\")]').text_content()\n        assert next_question_number_text.strip() == '5 / 890'\n        # Click '➡️ Sonraki Soru' again to advance to question 6 and verify\n        await frame.locator('text=➡️ Sonraki Soru').click()\n        await page.wait_for_timeout(3000)\n        next_question_number_text_2 = await frame.locator('xpath=//div[contains(text(),\"6 / 890\")]').text_content()\n        assert next_question_number_text_2.strip() == '6 / 890'\n        # Click '🏁 Oyunu Bitir' to end the game and verify the game ends properly\n        await frame.locator('text=🏁 Oyunu Bitir').click()\n        await page.wait_for_timeout(3000)\n        # Verify that after ending the game, the question area is cleared or shows game ended message\n        game_ended_text = await frame.locator('xpath=//div[contains(text(),\"Oyun Bitti\") or contains(text(),\"Quiz Ended\")]').text_content()\n        assert game_ended_text is not None\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112709132726//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.803Z",
    "modified": "2025-10-10T16:11:49.378Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "8570899e-02a1-4b83-bba7-ed958d599cee",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC008-Quiz Host starts a random game and question flow is randomized",
    "description": "Verify that starting a game in random mode causes questions to be delivered in a non-deterministic order to players.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Oyun Sunucusu' (Game Server) to start quiz hosting\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Rastgele Mod' to select random game mode\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' to start the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Copy the participation link to simulate or facilitate player joining\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' to start the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sonraki Soru' (Next Question) to get the next question and verify order\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sonraki Soru' (Next Question) to proceed to question 3 and continue verifying question order\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sonraki Soru' (Next Question) to proceed to question 4 and continue verifying question order\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sonraki Soru' (Next Question) to proceed to question 5 and continue verifying question order\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sonraki Soru' (Next Question) to proceed to question 6 and continue verifying question order\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Bitir' (End Game) to finish the current random mode game and prepare for sequential mode test\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Yeni Oyun' to start a new game and select sequential mode for comparison\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Sıralı Mod' to select sequential mode and start the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: Unable to verify random order of questions due to unknown expected result.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The quiz game was successfully started in random mode and multiple questions were observed. The questions appeared in a non-deterministic order as expected for random mode. The game was then ended and the system navigated to the sequential mode selection screen, ready for a sequential mode test to compare question order. Since the sequential mode test was not performed yet, the task to fully verify non-deterministic question delivery is not fully complete.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[ERROR] ❌ Link kopyalanamadı: NotAllowedError: Failed to execute 'writeText' on 'Clipboard': Write permission denied. (at http://localhost:5173/src/components/QuizHost.tsx:253:14)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112965151985//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.817Z",
    "modified": "2025-10-10T16:16:05.398Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "b8462d28-2c85-4ab9-8f49-588170d2a266",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC009-Players join game by scanning QR code",
    "description": "Ensure that players scanning QR code receive the correct game join link and successfully join the game lobby.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Admin Paneli' to login as admin and manage questions.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input admin username and password and click login.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to main menu to start quiz hosting and generate QR code.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to start the quiz hosting and generate the QR code for players.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to start the game and generate the QR code for players to scan.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate player scanning QR code by opening the participation link in a new tab and submitting a player name to join the game lobby.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Input player name and click 'Oyuna Katıl' to join the game lobby.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Player1')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Test answering the question by inputting an answer and submitting it to verify game flow.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate a second player joining via the QR code link to verify multiple players can join and are listed in the lobby.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Simulate a second player joining via the QR code link to verify multiple players can join and are listed in the lobby.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Simulate a second player joining via the QR code link to verify multiple players can join and are listed in the lobby.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Open a new tab to simulate a second player joining via the QR code link to verify multiple players can join and are listed in the lobby.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Return to main menu to simulate a second player joining from a new session or tab to verify multiple players can join and are listed in the lobby.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to start a new game session to simulate a second player joining and verify multiple players can join and are listed.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the player has joined the game lobby and is listed among current participants.\n        frame = context.pages[-1]\n        await page.wait_for_timeout(3000)\n        participants_list = frame.locator('xpath=//div[contains(@class, \"participants-list\")]//div[contains(text(), \"Player1\")]')\n        assert await participants_list.count() > 0, \"Player1 should be listed in the game lobby participants.\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112579304328//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.832Z",
    "modified": "2025-10-10T16:09:39.437Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "70595681-fd25-43cb-839f-d1c026f3a120",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC010-Player joins game manually via code and enters name",
    "description": "Verify a player can join an ongoing game by manually entering game code and player name correctly.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Navigate to player interface for joining game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to player interface for joining ongoing game by entering code and player name\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to proceed towards game server options and find player join interface\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to check if it leads to player join interface\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Find and navigate to the manual game code and player name entry interface for joining the game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Rastgele Mod' to check if it leads to player join interface with manual entry fields\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Generic failing assertion since expected result is unknown\n        assert False, 'Test failed: Player did not join the game lobby as expected.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The player join interface lacks the manual entry fields for game code and player name required to verify player joining an ongoing game. Testing stopped and issue reported.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112527372767//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.847Z",
    "modified": "2025-10-10T16:08:47.572Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "191cb18f-3578-4c11-917a-0f2022a84949",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC011-Player receives questions in real-time and submits answers",
    "description": "Confirm that players receive quiz questions instantly via Socket.IO events, can select answer choices and submit them successfully.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Panel to login as admin\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password, then click login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Add a new question manually by filling question and correct answer, then click 'Soru Ekle'\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('What is the capital of France?')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Paris')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Ana Menü' button to go back to main menu for quiz hosting\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to start and manage the quiz game server\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to start the quiz in sequential mode\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' button to start the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open a new tab to simulate or join as a player to verify real-time question reception and answer submission\n        await page.goto('http://localhost:5173/player', timeout=10000)\n        \n\n        # Click on 'Oyun Sunucusu' to join the running quiz game as a player\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to join the running quiz game in sequential mode as a player\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' button to start the quiz game as player and receive questions\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open a new tab to simulate a player joining the quiz game using the provided join link or QR code\n        await page.goto('http://localhost:5173/player', timeout=10000)\n        \n\n        # Click on 'Oyun Sunucusu' to join the quiz game as a player\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to join the quiz game as a player\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test plan execution failed: generic failure assertion'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The quiz application was tested through the full flow: admin login, question management, quiz hosting, and player interface navigation. The quiz game started successfully on the server side with players connected. However, on the player side, no players joined the game, preventing the game from starting and thus real-time question reception and answer submission could not be verified. Therefore, the core task of confirming that players receive quiz questions instantly via Socket.IO events, can select answer choices, and submit them successfully remains unconfirmed. Further testing requires simulating or connecting actual players to join the game and participate in the quiz. Task is not fully finished.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[ERROR] ❌ Soru ekleme hatası: Error: Bu soru zaten mevcut!\n    at Socket2.<anonymous> (http://localhost:5173/src/components/AdminPanel.tsx:166:20)\n    at Socket2.onack (http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:2694:9)\n    at Socket2.onpacket (http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:2618:14)\n    at Emitter.emit (http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:354:20)\n    at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:3218:12 (at http://localhost:5173/src/components/AdminPanel.tsx:170:14)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112697219928//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.857Z",
    "modified": "2025-10-10T16:11:37.451Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "d354f31f-e32d-4e9f-8569-27b6b90f96d6",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC012-Player receives live score and ranking updates",
    "description": "Ensure players see accurate and timely score and ranking updates during the quiz game as scores are calculated.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Panel to login and manage questions\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password and click login button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Add a new question manually by filling question and answer fields and clicking 'Soru Ekle' button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('What is the capital of France?')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Paris')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to main menu to start hosting a quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' to start hosting a quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Start the quiz game by selecting 'Sıralı Mod' (Sequential Mode) to host the quiz\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' to start the quiz game and proceed to question answering phase\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '➡️ Sonraki Soru' to proceed to next question and observe score and ranking updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '➡️ Sonraki Soru' to proceed to question 3 and observe score and ranking updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '➡️ Sonraki Soru' to proceed to question 4 and observe score and ranking updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '➡️ Sonraki Soru' to proceed to question 5 and observe score and ranking updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # End the quiz game by clicking '🏁 Oyunu Bitir' to complete the test\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Return to main menu to complete the test\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that after each question, the live score and ranking updates are displayed promptly\n        for i in range(1, 6):  # Assuming 5 questions as per the test steps\n            # Wait for the score element to be visible and contain updated score text\n            score_locator = frame.locator('xpath=//div[contains(@class, \"score\")]')\n            await score_locator.wait_for(state='visible', timeout=5000)\n            score_text = await score_locator.inner_text()\n            assert score_text.strip() != '', f'Score text should not be empty after question {i}'\n            # Wait for the ranking element to be visible and contain updated ranking text\n            ranking_locator = frame.locator('xpath=//div[contains(@class, \"ranking\")]')\n            await ranking_locator.wait_for(state='visible', timeout=5000)\n            ranking_text = await ranking_locator.inner_text()\n            assert ranking_text.strip() != '', f'Ranking text should not be empty after question {i}'\n            # Click '➡️ Sonraki Soru' to proceed to next question except after last question\n            if i < 5:\n                next_question_button = frame.locator('xpath=//button[contains(text(), \"➡️ Sonraki Soru\")]')\n                await next_question_button.click()\n                await page.wait_for_timeout(3000)  # Wait for updates to reflect\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112659803368//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.869Z",
    "modified": "2025-10-10T16:10:59.975Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "39821f2f-3227-482f-b185-c11ee14ce606",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC013-Player answer submission after timer expiry is rejected",
    "description": "Verify that if a player attempts to submit an answer after the question timer has expired, the submission is rejected and an appropriate message is shown.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on 'Oyun Sunucusu' (Game Server) to start or join a quiz game.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' button to start the quiz game in sequential mode.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Copy the player link and open it in a new tab to join as a player.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Open the player link in a new tab to join the game as a player.\n        await page.goto('http://localhost:5173/#player', timeout=10000)\n        \n\n        # Input player name 'TestPlayer' and click 'Oyuna Katıl' to join the game.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPlayer')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Switch back to the game lobby tab and start the quiz game by clicking 'Oyunu Başlat'.\n        await page.goto('http://localhost:5173/#game', timeout=10000)\n        \n\n        # Input answer '2' and click 'Cevabı Gönder' to attempt submission after timer expiration.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify if there is any message or UI element indicating late submission rejection or try submitting another answer after waiting for the timer to expire again.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('999')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Submission after timer expiration should be rejected, but no rejection message was verified.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Tested submitting an answer after the question timer expired. The system accepted the submission and showed a confirmation message instead of rejecting it. No appropriate message about late submission was shown. Therefore, the requirement that late submissions should be rejected and notified is not met.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[ERROR] ❌ Link kopyalanamadı: NotAllowedError: Failed to execute 'writeText' on 'Clipboard': Write permission denied. (at http://localhost:5173/src/components/QuizHost.tsx:253:14)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/176011256898//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.900Z",
    "modified": "2025-10-10T16:09:29.163Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "83d786e7-203b-46ac-a4a2-5c7add9419b2",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC014-Player connection loss and reconnection",
    "description": "Test that when a player loses connection temporarily during an active quiz, they can reconnect automatically or manually and resume the game state without data loss.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click Admin Panel to login and manage questions\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password, then click login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate back to main menu to host a quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' (Game Server) to start hosting the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' to start the quiz game in sequential mode\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' to start the quiz game and proceed to question answering phase\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate player answering the first question\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate network disconnection for a player and verify UI shows connection lost message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate network disconnection for a player and verify UI shows connection lost message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate network disconnection for a player and verify UI shows connection lost message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate network disconnection for a player and verify UI shows connection lost message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed due to unknown expected result after network reconnection.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to inability to simulate network disconnection or reconnection without players joined. The quiz game setup is complete, but the critical test of connection loss and recovery cannot be performed. Please ensure players can join the game to test this functionality.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)\n[ERROR] ❌ Link kopyalanamadı: NotAllowedError: Failed to execute 'writeText' on 'Clipboard': Write permission denied. (at http://localhost:5173/src/components/QuizHost.tsx:253:14)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112643200512//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.926Z",
    "modified": "2025-10-10T16:10:43.366Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "648dc212-4a3f-4305-abfb-a45f2441a3ad",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC015-Admin panel user access restriction enforcement",
    "description": "Ensure that access to the admin panel is restricted only to authenticated and authorized users and unauthorized users cannot access or perform admin actions.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Attempt to access admin panel URL without login by clicking 'Admin Paneli'\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username 'OSMAN' and password '80841217' and attempt login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Logout from admin panel and attempt to login as non-admin user to verify access denial\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to login as non-admin user with username 'nonadmin' and password 'password' (assuming these credentials or try to find alternative)\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('nonadmin')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assertion: Verify redirection to login screen or access denied message after attempting to access admin panel without login\n        frame = context.pages[-1]\n        login_heading = await frame.locator('xpath=//div[contains(text(),\"Admin Girişi\")]').text_content()\n        assert login_heading == \"Admin Girişi\", f\"Expected login heading 'Admin Girişi', but got {login_heading}\"\n        \n        # Assertion: Verify access to admin functions is denied for non-admin user\n        # Check for presence of access denied message or absence of admin panel elements\n        access_denied_message = await frame.locator('xpath=//*[contains(text(),\"Erişim Reddedildi\") or contains(text(),\"Access Denied\")]').count()\n        admin_panel_elements = await frame.locator('xpath=//div[contains(text(),\"Admin Paneli\")]').count()\n        assert access_denied_message > 0 or admin_panel_elements == 0, \"Non-admin user should not have access to admin panel or should see access denied message\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/17601124026371//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.934Z",
    "modified": "2025-10-10T16:06:42.765Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "f3abe6c5-e59a-4ea0-ad25-654276d4b000",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC016-Excel file upload API returns proper error for unsupported file types",
    "description": "Verify that attempting to upload non-Excel files or unsupported formats is rejected by the backend with meaningful error messages.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Panel to proceed to login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password and click login\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to upload a non-Excel file (e.g., .txt) and verify backend rejection and error message\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to find an alternative way to upload a non-Excel file or simulate the upload via other means, or check for drag and drop or other upload methods.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to upload a non-Excel file by using a drag and drop or other method if available, or simulate the upload by triggering the file input element with a test file programmatically if possible.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Try to upload a non-Excel file by clicking the file input label (index 7) and simulate file selection if possible, then click the upload button (index 8) to trigger backend validation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Attempt to upload a non-Excel file by clicking the file input label (index 7) and then clicking the upload button (index 8) to trigger backend validation and observe error message.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[4]/div[2]/div[2]/div/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        assert False, 'Test failed: Backend did not reject non-Excel file upload as expected.'\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to complete the task of verifying backend rejection of non-Excel files due to file input element restrictions and lack of alternative upload methods. Manual or backend API testing is recommended to verify validation and error handling for unsupported file formats.\nBrowser Console Logs:\n[WARNING] WebSocket connection to 'ws://localhost:5173/socket.io/?EIO=4&transport=websocket' failed: WebSocket is closed before the connection is established. (at http://localhost:5173/node_modules/.vite/deps/socket__io-client.js?v=8234457f:1034:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112518734635//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.946Z",
    "modified": "2025-10-10T16:08:38.870Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "649a71d2-f01a-4780-82d9-b256f66f513e",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC017-QR code correctly encodes game join link",
    "description": "Test that the generated QR code encodes a valid game join URL which when decoded is accurate and allows player joining.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-10-10T16:03:06.963Z",
    "modified": "2025-10-10T16:03:06.963Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "575cbfa3-d0cb-49a6-9c8b-c9cefcb4d7d7",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC018-RESTful API returns correct questions list",
    "description": "Verify that the REST API endpoint for retrieving quiz questions returns accurate and complete question data in expected format.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Send GET request to questions API endpoint to verify question data\n        await page.goto('http://localhost:5173/api/questions', timeout=10000)\n        \n\n        response = await page.content()\n        import json\n        data = json.loads(response)\n        assert 'content' in data, \"Response JSON should have 'content' key\"\n        questions = data['content']\n        assert isinstance(questions, list), \"'content' should be a list\"\n        assert len(questions) > 0, \"Questions list should not be empty\"\n        for question in questions:\n            assert 'question' in question, \"Each question should have 'question' field\"\n            assert 'answer' in question, \"Each question should have 'answer' field\"\n            assert isinstance(question['question'], str) and question['question'], \"Question text should be a non-empty string\"\n            assert isinstance(question['answer'], str) and question['answer'], \"Answer should be a non-empty string\"\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112335952614//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.987Z",
    "modified": "2025-10-10T16:05:36.128Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "ce50ed54-2035-4024-8d12-574bdbf6ad74",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC019-UI responsive design and styling consistency",
    "description": "Ensure that the application UI components render correctly and maintain consistent layout, gradient and glassmorphism effects across various device screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click Admin Panel to open login page and verify UI components on desktop.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password, then click login button to verify login functionality and UI consistency.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Verify UI responsiveness and styling on tablet resolution by resizing viewport or simulating tablet screen.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        \n\n        # Simulate tablet screen resolution and verify main page UI components render correctly with consistent styling.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password, then click login button to verify login functionality and UI consistency on tablet resolution.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile screen resolution and verify Admin Panel UI components render correctly with consistent styling and layout.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        \n\n        # Click Oyun Sunucusu button to open quiz host view and verify UI components and styling on desktop resolution.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate tablet screen resolution and verify quiz host view UI components render correctly with consistent styling and layout.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        \n\n        # Click Oyun Sunucusu button to open quiz host view and verify UI components and styling on tablet resolution.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate mobile screen resolution and verify quiz host view UI components render correctly with consistent styling and layout.\n        await page.goto('http://localhost:5173/', timeout=10000)\n        \n\n        # Click Oyun Sunucusu button to open quiz host view and verify UI components and styling on desktop resolution.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Navigate to player view on desktop resolution and verify UI components and styling consistency.\n        await page.goto('http://localhost:5173/player', timeout=10000)\n        \n\n        # Simulate tablet screen resolution and verify player view UI components render correctly with consistent styling and layout.\n        await page.goto('http://localhost:5173/player', timeout=10000)\n        \n\n        # Simulate mobile screen resolution and verify player view UI components render correctly with consistent styling and layout.\n        await page.goto('http://localhost:5173/player', timeout=10000)\n        \n\n        # Assert page title is correct and visible on all views\n        assert await page.title() == 'MODERN QUIZ'\n        # Assert description text is present and correct\n        desc_locator = page.locator('text=Interaktif quiz deneyimi ile bilginizi test edin. Arkadaşlarınızla yarışın ve eğlenceli vakit geçirin.')\n        assert await desc_locator.is_visible()\n        # Assert Admin Paneli section is visible and has correct text\n        admin_panel_locator = page.locator('text=Soru ekleyin ve oyunu yönetin')\n        assert await admin_panel_locator.is_visible()\n        # Assert Oyun Sunucusu section is visible and has correct text\n        quiz_host_locator = page.locator('text=Quiz oyununu başlatın ve yönetin')\n        assert await quiz_host_locator.is_visible()\n        # Assert UI elements have consistent styling for gradients and glassmorphism effects\n        # Check background gradient presence on main container\n        main_container = page.locator('div.main-container')\n        bg_gradient = await main_container.evaluate('(el) => window.getComputedStyle(el).backgroundImage.includes(\"gradient\")')\n        assert bg_gradient\n        # Check glassmorphism effect by verifying backdrop-filter or opacity on glass elements\n        glass_elements = page.locator('.glass-effect')\n        count_glass = await glass_elements.count()\n        assert count_glass > 0\n        for i in range(count_glass):\n            glass_style = await glass_elements.nth(i).evaluate('(el) => window.getComputedStyle(el).backdropFilter || window.getComputedStyle(el).opacity')\n            assert glass_style != ''\n        # Assert responsive layout by checking element sizes at different viewport widths\n        for width in [1920, 768, 375]:\n            await page.set_viewport_size({'width': width, 'height': 900})\n            await page.wait_for_timeout(1000)\n            # Check main container is visible and sized appropriately\n            main_container = page.locator('div.main-container')\n            assert await main_container.is_visible()\n            box = await main_container.bounding_box()\n            assert box['width'] <= width\n            # Check Admin Paneli and Oyun Sunucusu sections remain visible\n            assert await admin_panel_locator.is_visible()\n            assert await quiz_host_locator.is_visible()\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112615532835//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:06.995Z",
    "modified": "2025-10-10T16:10:15.666Z"
  },
  {
    "projectId": "ca28c8c8-376b-42c6-8c8f-b22fef517210",
    "testId": "f6623d63-fd5b-4bb5-905a-b1748fa53fa9",
    "userId": "b44874c8-d001-7032-f748-c763048b7555",
    "title": "TC020-Real-time game events are broadcast to all clients timely",
    "description": "Verify that Socket.IO events for player joins, question deliveries, answer confirmations, and score updates are properly emitted and received on all relevant clients without significant delay.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # Click on Admin Panel to login as admin\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Input username and password, then click login button\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('OSMAN')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('80841217')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Start hosting a quiz game to test real-time events\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Oyun Sunucusu' (Game Server) to start hosting the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click on 'Sıralı Mod' (Sequential Mode) to start the quiz game\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate multiple players joining the game using the join link or QR code, then click 'Oyunu Başlat' (Start Game) to begin the quiz\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click 'Oyunu Başlat' (Start Game) to begin the quiz and observe real-time Socket.IO events for question delivery, answer confirmation, and score updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate answer submissions from multiple players and verify real-time event propagation for answer confirmations and score updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Simulate answer submissions from multiple players and verify real-time event propagation for answer confirmations and score updates\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # End the game to complete the test and verify final score updates and event emissions\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '🏁 Oyunu Bitir' (End Game) to finish the quiz and verify final real-time events\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '🏁 Oyunu Bitir' (End Game) to finish the quiz and verify final real-time events\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Click '🏁 Oyunu Bitir' (End Game) to finish the quiz and verify final real-time events\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Return to main menu to complete the test\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # Assert that the server status is connected indicating real-time events can be received\n        assert await frame.locator('xpath=//div[contains(text(),\"Sunucu Bağlı\")]').is_visible()\n        \n        # Assert that the quiz title is correct\n        assert await frame.locator('xpath=//title[contains(text(),\"MODERN QUIZ\")]').is_visible() or (await page.title()) == \"MODERN QUIZ\"\n        \n        # Assert that game modes are displayed correctly\n        assert await frame.locator('xpath=//div[contains(text(),\"Sıralı Mod\")]').is_visible()\n        assert await frame.locator('xpath=//div[contains(text(),\"Rastgele Mod\")]').is_visible()\n        \n        # Since real-time Socket.IO events are internal and not directly visible on the page,\n        # we verify the UI updates that depend on these events such as player join notifications, question display, answer confirmation, and score updates.\n        # Check for player join notification or player count update\n        assert await frame.locator('xpath=//div[contains(text(),\"player joined\") or contains(text(),\"oyuncu katıldı\")]').is_visible() or await frame.locator('xpath=//div[contains(text(),\"Oyuncular\") or contains(text(),\"Players\")]').is_visible()\n        \n        # Check that a question is displayed after game start\n        assert await frame.locator('xpath=//div[contains(text(),\"Soru\") or contains(text(),\"Question\")]').is_visible()\n        \n        # Check for answer confirmation message or UI update\n        assert await frame.locator('xpath=//div[contains(text(),\"cevap\") or contains(text(),\"answer\") or contains(text(),\"doğru\") or contains(text(),\"correct\")]').is_visible()\n        \n        # Check for score update display\n        assert await frame.locator('xpath=//div[contains(text(),\"puan\") or contains(text(),\"score\") or contains(text(),\"skor\")]').is_visible()\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/b44874c8-d001-7032-f748-c763048b7555/1760112677344466//tmp/test_task/result.webm",
    "created": "2025-10-10T16:03:07.013Z",
    "modified": "2025-10-10T16:11:17.564Z"
  }
]
